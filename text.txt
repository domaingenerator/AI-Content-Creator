 Wowza Community Generate RTMP instead of m3u8 to play streaming in Android Hello, I wanna play camera encoded streaming to another android device so how to generate RTMP url instead of m3u8 because m3u8 does not work in android. Most Android devices support Apple HLS. Some support RTSP. I have not seen any Android devices support RTMP natively. You would likely need an application to play back RTMP on your Android device. We can provide no recommendations for RTMP or RTSP players on Android. The article below provides a list of how to form your URL for your specific player. https://www.wowza.com/docs/understanding-streaming-protocols-and-output-file-formats For example: RTMP: rtmp://[wowza-address]:1935/live/myStream RTSP: rtsp://[wowza-address]:1935/live/myStream Apple HLS: http://[wowza-address]:1935/live/myStream/playlist.m3u8 MPEG-DASH: http://[wowza-address]:1935/live/myStream/manifest.mpd Adobe HDS: http://[wowza-address]:1935/live/myStream/manifest.f4m Microsoft Smooth Streaming: http://[wowza-address]:1935/live/myStream/Manifest Hello I tried using below format but it gives error in VLC that unable to open MRL url rtmp://[wowza-address]:1935/live/myStream Is there any other way to generate RTMP Link from wowza cloud server. http://192.168.88.18:1935/live/STEREO/playlist.m3u8 rtmp://192.168.88.18:1935/live/STEREO Powered by Discourse, best viewed with JavaScript enabled © 2007–2022 Wowza Media Systems™, LLC. All rights reserved.   Security &amp; Privacy Policy | Legal | System Status Stream Stream Live Video Live Streaming Platform Online Video Platform (OVP) Over-the-Top (OTT) Video on Demand (VOD) Connect Broadcast Live Online China Content Delivery HTML5 Video Player Worldwide Delivery Solutions Expo Video Gallery Manage Online Video Hosting Video CMS Privacy &amp; Security Measure Video Analytics Video Monetization Video Marketing Events Live Events Streaming Broadcast Live Sports Live Fitness Classes Production and Publishing Business Video for Enterprises Video for Marketing Professionals Video for Sales Organizations Churches and Houses Of Worship Governments and Municipalities Education and e-Learning Institutions Entertainment and media Creative Agencies Live Streaming for Musicians TV and Radio Stations API Video API Video API Documentation Player API Documentation SDK Tools Developer Tools Video Transcoding Pay-Per-View Streaming Secure Video Upload Learning Center Blog Press Case Studies Support 24/7 Support Phone Support Professional Services Support Articles Knowledge Base FAQ Dacast About Us Careers Partners Contact Stream Stream Live Video Live Streaming Platform Online Video Platform (OVP) Over-the-Top (OTT) Video on Demand (VOD) Connect Broadcast Live Online China Content Delivery HTML5 Video Player Worldwide Delivery Solutions Expo Video Gallery Manage Online Video Hosting Video CMS Privacy &amp; Security Measure Video Analytics Video Monetization Video Marketing Events Live Events Streaming Broadcast Live Sports Live Fitness Classes Production and Publishing Business Video for Enterprises Video for Marketing Professionals Video for Sales Organizations Churches and Houses Of Worship Governments and Municipalities Education and e-Learning Institutions Entertainment and media Creative Agencies Live Streaming for Musicians TV and Radio Stations API Video API Video API Documentation Player API Documentation SDK Tools Developer Tools Video Transcoding Pay-Per-View Streaming Secure Video Upload Learning Center Blog Press Case Studies Support 24/7 Support Phone Support Professional Services Support Articles Knowledge Base FAQ Dacast About Us Careers Partners Contact +1 855-896-9300 Team Blog How to Convert RTMP to HLS for Live Video Streaming By Max Wilbert August 19, 2022August 22, 2022 10 Min Read Max Wilbert Max Wilbert is a passionate writer, live streaming practitioner, and has strong expertise in the video streaming industry. Table of Contents Share this post Sign up for a 14 Day trial. Table of Contents Do you know how to convert RTMP to HLS for live video streaming? RTMP and HLS are two streaming protocols that help transport live streams between the recording equipment, the encode, and the live streaming platform.  With the right video streaming host, you can automatically convert a single RTMP feed from your video encoder to HLS on the server end.  Here at Dacast, we use a stream packaging tool from Akamai for this process.   Today, we’re going to take a look at how Dacast and other video streaming platforms use these streaming protocols. We will define RTMP and HLS before comparing the roles of the two and discussing how to convert RTMP to HLS. Are you ready to learn about RTMP and HLS? Let’s get started! Table of Contents: What is a Streaming Protocol? First of all, when it comes to live streaming content, video files in various formats have to be transmitted from one device to another almost instantaneously. Video files are generally huge, making this feat quite impressive.  Streaming protocols are seemingly magical technology that makes live streaming possible. From a technical standpoint, video streaming protocols are standardized rules and methods for taking a large video file. This is done so that the files can be quickly delivered to the end user, where they are reassembled and turned back into videos you can watch. There are several video streaming protocols, but at this point, HLS is the most important, with RTMP coming in second.  What is RTMP? You need to use either live stream encoding software or a hardware encoder when setting up a live stream. The encoder connects to your video camera and other mobile live streaming equipment, then converts its RAW video output to a digital format better suited for live streaming. Most often, the default format for your encoder will be RTMP. RTMP stands for Real-Time Messaging Protocol and is a Macromedia (Adobe) standard created for real-time streaming audio, video, and associated data over the internet. It creates a constant connection between the client and server, which allows data to be quickly moved to the end user.  This protocol was initially created to transmit files from a server to a Flash video player. Since Flash is not used much anymore, many people assume RTMP has gone down with it.  Rather than dying out completely, RTMP has simply shifted gears. It is now responsible for feeding data to the streaming solution from the encoder.  This is a smaller role in the live streaming process, but it is still very important. This process is called ingest, and according to a 2021 Video Streaming Latency Report study, 76.6% of those surveyed used RTMP for ingesting.  Various streaming encoders—used by small operations and broadcast-level professionals, such as Wirecast, vMix, and OBS Studio—create feeds using RTMP. What is HLS? Have you heard of HLS streaming? If you haven’t, it is an essential piece of streaming technology you need to be aware of.  Apple created HLS streaming to allow video streaming on mobile devices with an iOS operating system, such as the iPhone and iPad. This was necessary because mobile devices using the iOS operating systems were not compatible with Flash Player and the RTMP technology used by Flash Player.  Mobile devices with an iOS operating system, including the iPhone and iPad, are not compatible with Flash Player, which primarily uses RTMP. HLS, which is shorthand for HTTP live streaming, was Apple’s solution to ensure that live video streaming was possible for its mobile users. Don’t worry, though; HLS is compatible with more than just Apple iOS devices. It is compatible with most internet-enabled devices. We’d like to point out that HLS is sometimes called an HTML5 video, but this is erroneous. HTML5 is an entirely different standard.  Converting RTMP to HLS for Live Streaming HLS is based on HTTP; the two formats exist for different types of devices. If you want to reach the largest possible audience with your live stream, you need to encode your RTMP stream to HLS. This is known as HLS ingest for live streaming. That way, the client’s device can access any of these streams. You can automatically convert a single RTMP feed from your video encoder to HLS on the server end with the right video streaming host.  Here at Dacast, we use a stream packaging tool from Akamai for this process.  Akamai uses RTMP ingest to deliver a stream from your encoder, then automatically transcodes the stream as HLS in near real-time, preparing the stream for any device format. This process does result in a minimal (30-45 second) delay on the camera feed. As you can see, converting RTMP to HLS for live video streaming happens behind the scenes, without the need for you to do much more than choose a service, like Dacast, that has the right tools to make this process happen.  Once the service transcodes the content, Dacast uses two top-tier live streaming CDNs (content delivery networks) to distribute the content via hundreds of thousands of servers worldwide.  This global service network ensures that live streams are delivered quickly and seamlessly to anywhere on the planet.  Using these top-tier video CDNs also helps to ensure reliability. If a server goes down or a million viewers suddenly show up for your broadcast, your content will continue to flow smoothly. All of this also means that any device can view your content seamlessly. The content delivery network automatically selects and delivers the best protocol automatically.  Using a global CDN reduces costs by ensuring that you only need one encoder. This means you can reach a global audience with a single setting and a single encoder. Benefits of HLS Streaming There are a few reasons why RTMP ingest to HLS streaming is so popular that you should be aware of.  Conclusion In this article, we’ve walked you through the basics of RTMP and HLS live streaming and the value of the RTMP to the HLS conversion process. If you’re looking for an easy way to convert your RTMP stream to HLS, we encourage investing in a live streaming solution like Dacast that makes the process absolutely seamless.  When you live stream with Dacast, your content is automatically available in whatever format is best for your viewers. Note: You can also access these full instructions on how to start live streaming with Dacast. When you go live, your content is automatically available in whatever format is best for your viewers. Want to stream live video on your website and maintain content control? We’ve got you covered! Plan to do regular, business-related broadcasts? We’ll help you make sure you reach all your viewers with the best quality stream possible. If you need additional help figuring out how to convert RTMP to HLS and HDS, or other support with live streaming, you can contact our technical support department from within your Dacast account. We invite you to try Dacast risk-free for 14 days. Access all of our features and see our powerful video streaming technology. All you have to do to get started is sign up today. No credit card is required.e Get Started For Free Did you find this article helpful? Do you have questions, comments, or ideas for other topics you’d like us to cover in our articles? Let us know in the comment section below, and thanks for reading! You can also join our LinkedIn group for regular live streaming tips and exclusive offers. Max Wilbert Max Wilbert is a passionate writer, live streaming practitioner, and has strong expertise in the video streaming industry. Sign up for a 14-Day trial. Read Next How to Set Up an RTMP Encoder for Live Video Streaming [Updated for 2022] Max Wilbert September 29, 2022September 29, 202240 Min Read How to Set Up a Live Streaming Website in 11 Simple Steps [2022 Update] Max Wilbert September 28, 2022October 04, 202230 Min Read What Is Transcoding and Why Is It Important to Video Streaming? Austen September 27, 2022September 27, 202210 Min Read Categories Get started Subscribe to stay up to date with our latest features and product releases. +1 855-896-9300 +44 80-8196-3009 +86 105-123-5043 English Español Italiano English Shop by category You are here People who viewed this item also viewed TV Service Worldwide Packages : Firestick ,Mag ,Android, Mac,M3u H.264 LAN HDMI Video Encoder HTTP RTSP RTMP UDP to IPTV Live Stream Streaming BEST DOWNLOADER CODE FOR FIRE TV AND ANDROID BOX 95% UPTIME RICOO IP-TV Set-Top Boxen Wand-Halterung Halter Aufhängung Befestigung Z0601 TinyENC1 Video Encoder Live Streaming HD H.264/H.265 HDMI Video 1080P RTSP RTMP Picture Information Image gallery - 1 of 10 Shop with confidence Seller information H.264 RTSP to RTMP &amp; m3u8 stream converter and pusher for IPCamera to Webcasting Item information H.264 RTSP to RTMP &amp; m3u8 stream converter and pusher for IPCamera to Webcasting Oops. Looks like we're having trouble connecting to our server. Refresh your browser window to try again. Description Postage and payments Item specifics Post to me Sales tax for an item #112828141881 Sales tax for an item #112828141881 Returns policy Payment details More to explore: Additional site navigation Features for Stream Hosting Providers Features for Individual Broadcasters Features for Stream Hosting Providers Features for Individual Broadcasters FAQ FIND THE ANSWERS YOU NEED How to use hybrid direct URL m3u8 and rtmp ? Please Note that in Hybrid Stream Direct Stream URL .m3u8 and RTMP automatic switching from webtv to live from encoder does not work.&nbsp;automatic switching works only from live encoder to webtvBelow details guide give you the idea to use Hybrid Direct URL m3u8 &amp; RTMP: If&nbsp;your channel is live broadcasting from WebTV and you want to switch live streaming from your Desktop-based Encoder or Hardware Encoder then the first login to your broadcaster dashboard and Click on &quot;WebTV Management&quot; &gt; &quot;Playlist Scheduler&quot;.Now Click on &quot;Stop Web TV Schedular&quot; before press start stream from your encoder like OBS and after press to start streaming you can &quot;Start Web TV Schedular&quot; again not need to wait untill finish your live stream encoder NOTE: This option will disable Scheduler WebTV stream only, not affect to live and hybrid stream. and after you stop Live Encoding from your Desktop-based Encoder or Hardware Encoder it will auto switch to WebTV. &nbsp; Sales & Support Our helpdesk is available from 7:00 AM to 11:00 PM Sunday to Saturday GMT +5:45. Company Resources Contact Us © Copyright Everest Cast Pvt. Ltd. 2022 . Made with by VDO Panel. rtmp from m3u8 Similar Threads Login Register Don’t have an account yet? Register yourself now and be a part of our community! Third-Party Login How to convert a http/rtmp, etc list into a m3u8 list There are 17 replies in this Thread which was already clicked 35,044 times. The last Post (Apr 8th 2020) by Melgas. Open NOTEPAD++ Click on NEW &gt; add the list of stream(s) click on CODIFICATION &gt; CODE IN UTF-8SAVE AS : this is where you save with "title .m3u8" without using " "below the save as: TYPE :NORMAL TEXT FILE (".txt)save it to your desktop.Done..  Thanks for this tutorial, it works in Text Wrangler for Mac users.:) how about m3u file? how to make it? how about m3u file? how to make it? Open NOTEPAD++Click on NEW &gt; add the list of stream(s)click on CODIFICATION &gt; CODE IN UTF-8SAVE AS : this is where you save with "title .m3u" without using " "below the save as: TYPE :NORMAL TEXT FILE (".txt)save it to your desktop.Done.. You follow the instructions from the first post#1 except instead of giving the extension of .m3u8 you simply give it the extension .m3uthe difference between the two is that m3u8 will accept different streams, http,rtmp,rtsp,,,,,,,,,,  this is exactly what I needed haven't tried it yet im sure it works fine im at work now will try when I get home thank you so much!!!!!!!!! do not forget to put #EXTM3U in the top of the list :   #EXTM3U  #EXTINF:-1,name of your channel 1http:// . . .   #EXTINF:-1, name of your channel 2http://. . . . I add the url of every ipTv channel to my receiver with remote control and that is tiring and cost too much time. Is there anyway to make a file for all url's and in which format i have to make it to add all in one time via an USB flash ? open notepad  write this text :  #EXTM3U  #EXTINF:-1,name of your channel 1http://adress.m3u   #EXTINF:-1, name of your channel 2http://your adress2.m3u    save de file : click on file / save as / save as type : all files , file name : my playlist.m3u , encoding utf-8  (in attachment the m3u file template ) Files i did copied all my http links to the template providet by rappy, ftp to etc tsmedia m3u , tried to play but not working.  the links are working ok on simpletv so how can i get them to work on ee2 Edited once, last by misk (Apr 3rd 2015). Hi, how an i convert this rtmp://144.76.91.10:1935/cms/cyextra to play to enigma 2 receiver? thanks Hi, how an i convert this rtmp://144.76.91.10:1935/cms/cyextra to play to enigma 2 receiver? thanks       ftp to/etc/enigma2/playlist.e2pls   open playlist.e2pls  paste this insave   open mediaplayer plugin on you sat boxpress menu switch to playlistplay the stream thanks i add this 4097:0:1:0:0:0:0:0:0:0:rtmp%3a//144.76.91.10%3a1935/cms/cyextra:extra in my bouquet and it's play good , i don't use playlist but how you convert? you change the : with this %3a and you add :extra yes  you change the : with this %3a and you add :extra sorry bur d ont work with me ,i need change link http to rtmp but not work with me hola me puedes ayudar a transformar esta lista para poder usarlo en ssiptv   TVR 1rtmp://212.83.171.82:1935/live/001TVR 2rtmp://212.83.171.82:1935/live/002PAPRIKA TVrtmp://212.83.171.82:1935/live/003TRAVEL CHANNELrtmp://212.83.171.82:1935/live/004DIGI SPORT 3rtmp://212.83.171.82:1935/live/005TV 1000rtmp://212.83.171.82:1935/live/006DIGI ANIMALrtmp://212.83.171.82:1935/live/007VIASAT NATURErtmp://212.83.171.82:1935/live/008PRO TVrtmp://212.83.171.82:1935/live/009ANTENA 1rtmp://212.83.171.82:1935/live/010KANAL Drtmp://212.83.171.82:1935/live/011ANTENA 3rtmp://212.83.171.82:1935/live/012PARAMOUNTrtmp://212.83.171.82:1935/live/013EUROSPORT 1rtmp://212.83.171.82:1935/live/014EUFORIA LIFESTYLErtmp://212.83.171.82:1935/live/015ZU TVrtmp://212.83.171.82:1935/live/016FISHING AND HUNTINGrtmp://212.83.171.82:1935/live/017ANTENA STARSrtmp://212.83.171.82:1935/live/018ROMANIA TVrtmp://212.83.171.82:1935/live/019AXNrtmp://212.83.171.82:1935/live/020RAI 1rtmp://212.83.171.82:1935/live/023REALITATEArtmp://212.83.171.82:1935/live/024COMEDY CENTRALrtmp://212.83.171.82:1935/live/025TVR 3rtmp://212.83.171.82:1935/live/026MTVrtmp://212.83.171.82:1935/live/027MONEY CHANNELrtmp://212.83.171.82:1935/live/029DIGI FILMrtmp://212.83.171.82:1935/live/030EUROSPORT 2rtmp://212.83.171.82:1935/live/031DIGI 24rtmp://212.83.171.82:1935/live/032DIGI SPORT 1rtmp://212.83.171.82:1935/live/033VIASAT HISTORYrtmp://212.83.171.82:1935/live/034KISS TVrtmp://212.83.171.82:1935/live/035PRIMA TVrtmp://212.83.171.82:1935/live/036B1rtmp://212.83.171.82:1935/live/037DIGI SPORT 2rtmp://212.83.171.82:1935/live/038MINIMAXrtmp://212.83.171.82:1935/live/040VIASAT EXPLORERrtmp://212.83.171.82:1935/live/0421 MUSICrtmp://212.83.171.82:1935/live/043DIGI LIFErtmp://212.83.171.82:1935/live/044DIGI WORLDrtmp://212.83.171.82:1935/live/045SUPER ONErtmp://212.83.171.82:1935/live/046CINEMAXrtmp://212.83.171.82:1935/live/047HBOrtmp://212.83.171.82:1935/live/048DIVA UNIVERSALrtmp://212.83.171.82:1935/live/050DISNEY JUNIORrtmp://212.83.171.82:1935/live/081DISNEY CHANNELrtmp://212.83.171.82:1935/live/082M1rtmp://212.83.171.82:1935/live/100RTL Klubrtmp://212.83.171.82:1935/live/101VIASAT 3rtmp://212.83.171.82:1935/live/103DUNA TVrtmp://212.83.171.82:1935/live/104NATIONAL TVrtmp://212.83.171.82:1935/live/107AXN BLACKrtmp://212.83.171.82:1935/live/108NAT GEO WILDrtmp://212.83.171.82:1935/live/113NATIONAL GEOGRAFICrtmp://212.83.171.82:1935/live/114PROTV HDrtmp://212.83.171.82:1935/live/120HBO HDrtmp://212.83.171.82:1935/live/121UTV HDrtmp://212.83.171.82:1935/live/122ACASA TV GOLDrtmp://212.83.171.82:1935/live/802DISCOVERY WORLDrtmp://212.83.171.82:1935/live/1001DISCOVERY SCIrtmp://212.83.171.82:1935/live/1002TLCrtmp://212.83.171.82:1935/live/1003RTL 2rtmp://212.83.171.82:1935/live/1004RTL+rtmp://212.83.171.82:1935/live/1005DUCK TVrtmp://212.83.171.82:1935/live/1007DISCOVERY IDrtmp://212.83.171.82:1935/live/1008DAVINCI LEARNINGrtmp://212.83.171.82:1935/live/1009HISTORYrtmp://212.83.171.82:1935/live/1010MGMrtmp://212.83.171.82:1935/live/1011CINEMAX 2rtmp://212.83.171.82:1935/live/1012FILM CAFErtmp://212.83.171.82:1935/live/1012LOOK TVrtmp://212.83.171.82:1935/live/1014LOOK TV PLUSrtmp://212.83.171.82:1935/live/1015******* USArtmp://212.83.171.82:1935/live/1016DORCEL TVrtmp://212.83.171.82:1935/live/1017EXOTICArtmp://212.83.171.82:1935/live/1018EXOTICA PLUSrtmp://212.83.171.82:1935/live/1018HBO COMEDYrtmp://212.83.171.82:1935/live/1019 How do you convert m3u to URL for mag250? Hi guys!!!  Hw can i convert this : for play to enigma 2 receiver?It was snifeed by Url helper 3.42.(from hrere:http://www.zahitvstation.com/watch-cnn-usa-live) THX 4 support!!! # Hello  I followed the instructions in Post 1. Unsuccessfully.  I want to put all these "Live Cams" in my Enigma2 Box (with IPTV): https://explore.org/livecams  I have this address working in my Box, for example: http://stream.africam.com:1935…ream_source/playlist.m3u8  As I will be able to collect all the other addresses, it is my request.  Thanks. # DM920-UHD4K + SF8008-UHD4K master GFeb 5th 2022 Participate now! Don’t have an account yet? Register yourself now and be a part of our community!   &nbsp; Share Tags Live Streaming: RTMP and HLS KeyCDN supports HTTP Live Streaming (HLS) based on a normal Pull Zone. This article describes shortly each protocol and elaborates the high level concept implemented by KeyCDN how live streaming can be done. Real Time Messaging Protocol (RTMP) RTMP is used to stream audio, video or data and is originally a proprietary protocol introduced by Macromedia (owned by Adobe). The protocol is TCP-based and offers therefore persistent connections. In short, RTMP encapsulates MP3/AAC audio and MP4/FLV video multimedia streams. If you do live streaming with KeyCDN, RTMP will not be used for video delivery to end users. If the streaming software is based on RTMP, you can use this protocol to initially stream your content to your server or a third party service that transforms the RTMP stream to HLS. A wide range of RTMP encoders can be used to create the live stream (e.g. FMLE, OBS, or WireCast). HTTP Live Streaming (HLS) HTTP Live Streaming is known as HLS. As the name implies, it is the media streaming communications protocol based on HTTP; developed by Apple as part of their QuickTime, Safari, macOS, and iOS products. How does it work? It breaks the overall stream into a sequence of small HTTP-based transport stream (.ts) files. These transport stream files are indexed in the UTF-8 M3U playlist (.m3u8) file. It is required to first download the M3U8 playlist to play a live stream. Why HLS for live steaming? iOS devices do not support RTMP and most web-based players such as JW player or Flowplayer require the Flash based version to play RTMP streams, but iOS devices can not handle the Flash players. The only proper solution is HLS. How does live streaming work with KeyCDN? If you do live streaming with KeyCDN, video delivery to end users is based on HLS (not RTMP). The basic sequence looks like this: The HLS feature for Pull Zones (called Optimize for HLS) manages the different HLS files accordingly. The index file (.m3u8) will not be cached. The actual video files (.ts) will be cached for 5 minutes. The following Zone settings are automatically updated: The HLS stream will then be pulled from your Origin URL (either your own server or a third party service that offers HLS). It's also possible to use different ports to pull the content from your HLS source (e.g. https://www.example.com:9999). Here is an example of how to integrate HTTP Live Streaming (HLS) with JW Player: Optimized HLS Streaming KeyCDN has added a new feature for better HTTP Live Streaming (HLS) with a regular Pull Zone… 8 Advanced Content Delivery Network Features Many people enable their content delivery network service and leave it at that. While you might be… Supercharge your content delivery 🚀 Try KeyCDN with a free 14 day trial, no credit card required. Comments Product Company Support TermsPrivacyGDPR Multistreaming Livestream to Facebook, YouTube, Twitch and 40+ platforms at the same time. starts from Free Plan Pre-recorded Live Scheduler Imagine converting a 2GB video file into a Facebook livestream starts from Free Plan Live Streaming CDN Deliver your livestreams to global audience with the High Performance Global CDN solution starts from $19 /month Products&nbsp;&nbsp; Game Streaming Stream live gameing to Twitch, Facebook & 40+ sites Church Streaming Livestream Holy events to believers across platforms Live TV Streaming Your Live TV streams equipped with HTML5 Player Solutions&nbsp;&nbsp; Multistream to 40+ Platforms Livestream to multiple platforms simultaneously Livestream Scheduling  Livestream MP4 Videos  Connect Social Media accounts Seamless integration with Facebook pages, Twitch and Youtube channels Livestream Recordings  Multi Chat Overlay  Managed Livestream Titles  Real Time Stream Monitoring  Saved Streams Reports  Built-in Teams Account  Developer API Tools  Features&nbsp;&nbsp; Pricing Sign in Sign up Test M3U8, DASH streams with Free HTML5 Player Test your HLS (M3U8), DASH stream urls with our faster HTML5 player Supports all major streaming platforms Live stream to 40+ popular streaming platforms simultaneously, plus Custom RTMP for anything else Regular Create live streams from recorded videos Absolutely Free &nbsp; Pro For as low as Deliver your live streams to every device with a faster Global CDN Bills $50 year See Full Pricing Editors For as low as Host videos, transcode to multiple resolutions, deliver with Global CDN Bills $96 year See Full Pricing Creators For as low as Host videos, transcode to multiple resolutions, deliver with Global CDN Bills $96 year See Full Pricing Trusted by beloved streamers Checkout how we've helped our customers with their livestreaming campaigns Frequently asked questions Have a look at our most asked questions or check our HelpCenter FAQs section. Yes, absolutely. The Free Plan too will let you multistream to multiple platforms simultaneously. With the Free Service plan, you can multi stream to 3 platforms for up to 20 hours per month. This 20 hours limit gets renewed automatically at the start of each month. For the moment, Livepush is the only multistreaming service that lets you livestream to Facebook pages for free. Also Check Understanding the Free Plan Simulated live is a concept of live streaming to YouTube and Facebook like platforms from pre-recorded videos. This process takes your pre-recorded video and simulates it into an actual live stream, so your viewers will see you as if you are streaming live but you are not. Livepush offers a pre-recorded live dashboard, which gives you the ability to record your planned event in advance and upload to your Livepush dashboard and turn it into an actual livestream and then multistream to YouTube, Facebook, Twitch and over 40 popular streaming platforms. Also check Livestream from MP4 videos and Livestream Scheduling From your Livepush dashboard, you can livestream pre recorded videos in three steps; You can schedule and livestream to Facebook using pre-recorded videos with our pre-recorded live dashboard. To do that, you will need to subscribe to our paid plans that supports the pre-recorded live streaming. We offer several Plans, each comes with its set of pre-recorded live features. Also check Pricing & Plans Explained Yes, you can upload 200MBs of videos and can livestream to upto 20 minutes per live event. Also check Pricing & Plans Explained Livepush supports all popular software and hardware encoders including; StreamLabs OBS (SLOBS), Xsplit, Wirecast, vMix, etc. You can quickly connect your OBS to Livepush by going to the "Settings" > "Stream'” > "Service set to Custom" and then manually entering the Livepush RTMP Server URL and your Stream Key. Also check How to stream live from OBS to Livepush Get started with Livepush Get started with your Free account, no credit card required Live video streaming & scheduling platform Products Solutions Resources Company Streamflex Labs, Inc. All Rights Reserved, 2022 ready-to-use RTSP / RTMP / LL-HLS server and proxy that allows to read, publish and proxy video and audio streams License aler9/rtsp-simple-server Use Git or checkout with SVN using the web URL. Work fast with our official CLI. Learn more. Launching GitHub Desktop If nothing happens, download GitHub Desktop and try again. Launching GitHub Desktop If nothing happens, download GitHub Desktop and try again. Launching Xcode If nothing happens, download Xcode and try again. Launching Visual Studio Code Your codespace will open once ready. There was a problem preparing your codespace, please try again. Latest commit Git stats Files README.md  rtsp-simple-server is a ready-to-use and zero-dependency server and proxy that allows users to publish, read and proxy live video and audio streams through various protocols: Features:  Table of contents Installation Standard Download and extract a precompiled binary from the release page. Start the server: Docker Download and launch the image: The --network=host flag is mandatory since Docker can change the source port of UDP packets for routing reasons, and this doesn't allow the server to find out the author of the packets. This issue can be avoided by disabling the UDP transport protocol: Please keep in mind that the Docker image doesn't include FFmpeg. if you need to use FFmpeg for an external command or anything else, you need to build a Docker image that contains both rtsp-simple-server and FFmpeg, by following instructions here. Basic usage Publish a stream. For instance, you can publish a video/audio file with FFmpeg: or GStreamer: To publish from other hardware / software, take a look at the Publish to the server section. Open the stream. For instance, you can open the stream with VLC: or GStreamer: or FFmpeg: General Configuration All the configuration parameters are listed and commented in the configuration file. There are 3 ways to change the configuration: By editing the rtsp-simple-server.yml file, that is included into the release bundle available in the root folder of the Docker image (/rtsp-simple-server.yml); it can be overridden in this way: The configuration can be changed dynamically when the server is running (hot reloading) by writing to the configuration file. Changes are detected and applied without disconnecting existing clients, whenever it's possible. By overriding configuration parameters with environment variables, in the format RTSP_PARAMNAME, where PARAMNAME is the uppercase name of a parameter. For instance, the rtspAddress parameter can be overridden in the following way: Parameters that have array as value can be overriden by setting a comma-separated list. For example: Parameters in maps can be overridden by using underscores, in the following way: This method is particularly useful when using Docker; any configuration parameter can be changed by passing environment variables with the -e flag: By using the HTTP API. Authentication Edit rtsp-simple-server.yml and replace everything inside section paths with the following content: Only publishers that provide both username and password will be able to proceed: It's possible to setup authentication for readers too: If storing plain credentials in the configuration file is a security problem, username and passwords can be stored as sha256-hashed strings; a string must be hashed with sha256 and encoded with base64: Then stored with the sha256: prefix: WARNING: enable encryption or use a VPN to ensure that no one is intercepting the credentials. Authentication can be delegated to an external HTTP server: Each time a user needs to be authenticated, the specified URL will be requested with the POST method and this payload: If the URL returns a status code that begins with 20 (i.e. 200), authentication is successful, otherwise it fails. Please be aware that it's perfectly normal for the authentication server to receive requests with empty users and passwords, i.e.: This happens because a RTSP client doesn't provide credentials until it is asked to. In order to receive the credentials, the authentication server must reply with status code 401 - the client will then send credentials. Encrypt the configuration The configuration file can be entirely encrypted for security purposes. An online encryption tool is available here. The encryption procedure is the following: NaCL's crypto_secretbox function is applied to the content of the configuration. NaCL is a cryptographic library available for C/C++, Go, C# and many other languages; The string is prefixed with the nonce; The string is encoded with base64. After performing the encryption, put the base64-encoded result into the configuration file, and launch the server with the RTSP_CONFKEY variable: Proxy mode rtsp-simple-server is also a proxy, that is usually deployed in one of these scenarios: Edit rtsp-simple-server.yml and replace everything inside section paths with the following content: After starting the server, users can connect to rtsp://localhost:8554/proxied, instead of connecting to the original url. The server supports any number of source streams, it's enough to add additional entries to the paths section: It's possible to save bandwidth by enabling the on-demand mode: the stream will be pulled only when at least a client is connected: Remuxing, re-encoding, compression To change the format, codec or compression of a stream, use FFmpeg or GStreamer together with rtsp-simple-server. For instance, to re-encode an existing stream, that is available in the /original path, and publish the resulting stream in the /compressed path, edit rtsp-simple-server.yml and replace everything inside section paths with the following content: Save streams to disk To save available streams to disk, you can use the runOnReady parameter and FFmpeg: In the example configuration, streams are saved into TS files, that can be read even if the system crashes, while MP4 files can't. On-demand publishing Edit rtsp-simple-server.yml and replace everything inside section paths with the following content: The command inserted into runOnDemand will start only when a client requests the path ondemand, therefore the file will start streaming only when requested. Start on boot Linux Systemd is the service manager used by Ubuntu, Debian and many other Linux distributions, and allows to launch rtsp-simple-server on boot. Download a release bundle from the release page, unzip it, and move the executable and configuration in the system: Create the service: Enable and start the service: Windows Download the WinSW v2 executable and place it into the same folder of rtsp-simple-server.exe. In the same folder, create a file named WinSW-x64.xml with this content: Open a terminal, navigate to the folder and run: The server is now installed as a system service and will start at boot time. HTTP API The server can be queried and controlled with an HTTP API, that must be enabled by setting the api parameter in the configuration: The API listens on apiAddress, that by default is 127.0.0.1:9997; for instance, to obtain a list of active paths, run: Full documentation of the API is available on the dedicated site. Metrics A metrics exporter, compatible with Prometheus, can be enabled with the parameter metrics: yes; then the server can be queried for metrics with Prometheus or with a simple HTTP request: Obtaining: where: pprof A performance monitor, compatible with pprof, can be enabled with the parameter pprof: yes; then the server can be queried for metrics with pprof-compatible tools, like: Compile and run from source Install Go 1.18, download the repository, open a terminal in it and run: You can perform the entire operation inside Docker: Publish to the server From a webcam To publish the video stream of a generic webcam to the server, edit rtsp-simple-server.yml and replace everything inside section paths with the following content: If the platform is Windows: Where USB2.0 HD UVC WebCam is the name of your webcam, that can be obtained with: After starting the server, the webcam can be reached on rtsp://localhost:8554/cam. From a Raspberry Pi Camera rtsp-simple-server natively support the Raspberry Pi Camera, enabling high-quality and low-latency video streaming from the camera to any user. To make the video stream of a Raspberry Pi Camera available on the server: The server must be installed on a Raspberry Pi, with Raspberry Pi OS bullseye or newer as operative system, and must be installed by using the standard method (Docker is not actually supported). If you're using the 64-bit version of the operative system, you need to pick the arm64 variant of the server. Make sure that the legacy camera stack is disabled. Type: Then go to Interfacing options, enable/disable legacy camera support, choose no. Reboot the system. edit rtsp-simple-server.yml and replace everything inside section paths with the following content: After starting the server, the camera can be reached on rtsp://raspberry-pi:8554/cam or http://raspberry-pi:8888/cam. Camera settings can be changed by using the rpiCamera* parameters: All available parameters are listed in the sample configuration file. From OBS Studio OBS Studio can publish to the server by using the RTMP protocol. In Settings -&gt; Stream (or in the Auto-configuration Wizard), use the following parameters: If credentials are in use, use the following parameters: From OpenCV To publish a video stream from OpenCV to the server, OpenCV must be compiled with GStreamer support, by following this procedure: Videos can be published with VideoWriter: Read from the server From VLC and Ubuntu The VLC shipped with Ubuntu 21.10 doesn't support playing RTSP due to a license issue (see here and here). To overcome the issue, remove the default VLC instance and install the snap version: Then use it to read the stream: RTSP protocol General usage RTSP is a standardized protocol that allows to publish and read streams; in particular, it supports different underlying transport protocols, that are chosen by clients during the handshake with the server: The default transport protocol is UDP. To change the transport protocol, you have to tune the configuration of your client of choice. TCP transport The RTSP protocol supports the TCP transport protocol, that allows to receive packets even when there's a NAT/firewall between server and clients, and supports encryption (see Encryption). You can use FFmpeg to publish a stream with the TCP transport protocol: You can use FFmpeg to read that stream with the TCP transport protocol: You can use GStreamer to read that stream with the TCP transport protocol: You can use VLC to read that stream with the TCP transport protocol: UDP-multicast transport The RTSP protocol supports the UDP-multicast transport protocol, that allows a server to send packets once, regardless of the number of connected readers, saving bandwidth. This mode must be requested by readers when handshaking with the server; once a reader has completed a handshake, the server will start sending multicast packets. Other readers will be instructed to read existing multicast packets. When all multicast readers have disconnected from the server, the latter will stop sending multicast packets. If you want to use the UDP-multicast protocol in a Wireless LAN, please be aware that the maximum bitrate supported by multicast is the one that corresponds to the lowest enabled WiFi data rate. For instance, if the 1 Mbps data rate is enabled on your router (and it is on most routers), the maximum bitrate will be 1 Mbps. To increase the maximum bitrate, use a cabled LAN or change your router settings. To request and read a stream with UDP-multicast, you can use FFmpeg: or GStreamer: or VLC (append ?vlcmulticast to the URL): Encryption Incoming and outgoing RTSP streams can be encrypted with TLS (obtaining the RTSPS protocol). A TLS certificate is needed and can be generated with OpenSSL: Edit rtsp-simple-server.yml, and set the protocols, encryption, serverKey and serverCert parameters: Streams can be published and read with the rtsps scheme and the 8322 port: If the client is GStreamer, disable the certificate validation: At the moment VLC doesn't support reading encrypted RTSP streams. A workaround consists in launching an instance of rtsp-simple-server on the same machine in which VLC is running, using it for reading the encrypted stream with the proxy mode, and reading the proxied stream with VLC. Redirect to another server To redirect to another server, use the redirect source: Fallback stream If no one is publishing to the server, readers can be redirected to a fallback path or URL that is serving a fallback stream: Corrupted frames In some scenarios, when reading RTSP from the server, decoded frames can be corrupted or incomplete. This can be caused by multiple reasons: the packet buffer of the server is too small and can't keep up with the stream throughput. A solution consists in increasing its size: The stream throughput is too big and the stream can't be sent correctly with the UDP transport. UDP is more performant, faster and more efficient than TCP, but doesn't have a retransmission mechanism, that is needed in case of streams that need a large bandwidth. A solution consists in switching to TCP: In case the source is a camera: RTMP protocol General usage RTMP is a protocol that allows to read and publish streams, but is less versatile and less efficient than RTSP (doesn't support UDP, encryption, doesn't support most RTSP codecs, doesn't support feedback mechanism). It is used when there's need of publishing or reading streams from a software that supports only RTMP (for instance, OBS Studio and DJI drones). At the moment, only the H264 and AAC codecs can be used with the RTMP protocol. Streams can be published or read with the RTMP protocol, for instance with FFmpeg: or GStreamer: Credentials can be provided by appending to the URL the user and pass parameters: Encryption RTMP connections can be encrypted with TLS, obtaining the RTMPS protocol. A TLS certificate is needed and can be generated with OpenSSL: Edit rtsp-simple-server.yml, and set the rtmpEncryption, rtmpServerKey and rtmpServerCert parameters: Streams can be published and read with the rtmps scheme and the 1937 port: Please be aware that RTMPS is currently unsupported by VLC, FFmpeg and GStreamer. However, you can use a proxy like stunnel or nginx to allow RTMP clients to access RTMPS resources. HLS protocol General usage HLS is a protocol that allows to embed live streams into web pages. It works by splitting streams into segments, and by serving these segments with the HTTP protocol. Every stream published to the server can be accessed by visiting: where mystream is the name of a stream that is being published. Please be aware that HLS only supports a single H264 video track and a single AAC audio track due to limitations of most browsers. If you want to use HLS with streams that use other codecs, you have to re-encode them, for instance by using FFmpeg: Embedding The simples way to embed a live stream into a web page consists in using an iframe tag: Alternatively you can create a video tag that points directly to the stream playlist: Please note that most browsers don't support HLS directly (except Safari); a Javascript library, like hls.js, must be used to load the stream. You can find a working example by looking at the source code of the HLS muxer. Low-Latency variant Low-Latency HLS is a recently standardized variant of the protocol that allows to greatly reduce playback latency. It works by splitting segments into parts, that are served before the segment is complete. LL-HLS is disabled by default. To enable it, a TLS certificate is needed and can be generated with OpenSSL: Set the hlsVariant, hlsEncryption, hlsServerKey and hlsServerCert parameters in the configuration file: Every stream published to the server can be read with LL-HLS by visiting: If the stream is not shown correctly, try tuning the hlsPartDuration parameter, for instance: Decreasing latency in HLS, latency is introduced since a client must wait for the server to generate segments before downloading them. This latency amounts to 1-15secs depending on the duration of each segment, and to 500ms-3s if the Low-Latency variant is enabled. To decrease the latency, you can: enable the Low-Latency variant of the HLS protocol, as explained in the previous section; if Low-latency is enabled, try decreasing the hlsPartDuration parameter; try decreasing the hlsSegmentDuration parameter; The segment duration is influenced by the interval between the IDR frames of the video track. An IDR frame is a frame that can be decoded independently from the others. The server changes the segment duration in order to include at least one IDR frame into each segment. Therefore, you need to decrease the interval between the IDR frames. This can be done in two ways: if the stream is being hardware-generated (i.e. by a camera), there's usually a setting called Key-Frame Interval in the camera configuration page otherwise, the stream must be re-encoded. It's possible to tune the IDR frame interval by using ffmpeg's -g option: Links Related projects Standards About ready-to-use RTSP / RTMP / LL-HLS server and proxy that allows to read, publish and proxy video and audio streams Topics Resources License Stars Watchers Forks Releases 111 Sponsor this project Contributors 21 Languages Footer Footer navigation &nbsp; Zype Acquires MAZ Systems to Extend Leading Video API and Infrastructure Platform with No-Code TV and Mobile App Publishing Framework HLS or RTMP for Livestreaming: It’s Not Really a Choice Anymore When it comes to streaming media content, there are two well-known protocols, HLS and RTMP. The former stands for HTTP livestreaming, while RTMP is short for real-time media protocol. In practice, HLS has been designed to stream media over the HTTP protocol, while RTMP streams content via TCP or UDP protocols. Apple introduced HLS, while Adobe had a central role in creating RTMP. hbspt.cta._relativeUrls=true;hbspt.cta.load(8760498, '924c4690-01ea-4fc7-a851-3361116329fc', {"useNewLoader":"true","region":"na1"}); Consumers are no longer content with solely receiving video content in their living rooms. Instead, desktop, laptop, and mobile devices are now the preferred video destination for many, which opens the door to livestreaming for businesses, organizations, and individuals alike. HLS Years ago, Adobe Flash was the preferred method to transfer video content across the web. Today, open protocols like HLS streaming (and HTML5) have largely taken over. For broadcasters and viewers, this change has been a positive one. With HLS streaming, there’s more flexibility and safety, and performance is much more reliable than previous technologies. HLS has become a mixed bag for those who produce content, if only because switching equipment requires time and resources. More Information The adoption of HLS has been swift because of its easy transmission and compatibility. It is supported on desktop browsers, smart TVs, and mobile devices, including Android and iOS. Its biggest drawback is latency, although there are methods to reduce HLS latency. RTMP Years ago, RTMP was used to transmit content between video players and a hosting server. Today, its job is more significant as it delivers content from an encoder to an online video host. Behind the scenes, RTMP offers low-latency streaming with minimal buffering. Unfortunately, RTMP relies on the same Adobe Flash that was mentioned a few paragraphs above. As a result, this tool is no longer supported on web browsers or mobile devices. However, that doesn’t mean RTMP is no longer beneficial. Relating to Livestreaming To push live video content, you first need the right equipment to capture the video and audio. The content then needs to go through a video encoder. From here, the encoder pushes the content to a video hosting platform using the all-important RTMP. The platform then uses HLS ingest to transmit the content to a supported video player. In other words, using RTMP as a transport stream remains vital since it can be transcoded into other formats — like HLS, which may be distributed more efficiently. The key terms here are video encoder and HLS ingest. The first converts analog or digital video into another digital video format, which is then decoded. Put another way, a video encoder converts RAW video files into a suitable form for live broadcasting. Really Not a Contest, But Still Some Confusion RTMP is no longer the standard for live video streaming, but it’s still used behind the scenes and has a place in the process. As Mediastream rightly&nbsp;explains, "RTMP is the most widely used protocol for ingesting and HLS for playback. The latter is the most recommended by the company; its delivery is segmented. It is multi-quality adaptive and supports HTML5 ensuring fast transmissions with the best quality to more than a million users." There can remain some confusion for content producers, especially when you consider just how quickly technology changes. Because of this, businesses and organizations have turned to third-party platforms to help them with over-the-top (OTT) and livestreaming solutions. Companies like MAZ (now Zype Apps Creator) make sure your audience&nbsp;never misses a beat&nbsp;by providing livestreaming technologies like automatic ingest fail-over and adaptive-bitrate streaming. They also make it possible to bring your content to various platforms, including mobile, smart TVs, social media, and websites. &nbsp;  &nbsp; Related Articles How does Hulu make money? An in-depth Guide. Hulu’s prominent role in today’s so-called streaming wars places it within the group of big players, including Netflix, Amazon Prime Video and HBO Go. Boasting 25... Live Streaming and its Impact on Media and Entertainment Industry Video technology has evolved over the years, and people are increasingly consuming more and more video content. Cisco went so far as to predict that by 2021, videos... Solutions Support About Us Talk to an Expert What is M3U8? M3U8 is a computer file format that contains a multimediaplaylist. Normally the playlist points to a stream on the Internet.This player downloads the video specified in the M3U8 file and playswithin your browser. To get started, What is HLS? HLS stands for HTTP Live Streaming. It's a HTTP-based media streamingcommunications protocol implemented by Apple Inc. It works by breaking theoverall stream into a sequence of small file downloads,each download loading one short chunk of an overall potentiallyunbounded transport stream. HLS streams are usually described using M3U8 playlist. Browser Compatibility Most desktop and mobile browsers are supported. However, CORS must be enabledon the streaming server, otherwise it may not play. Creating A Production Ready Multi Bitrate HLS VOD stream&para; HLS is one of the most prominent video streaming formats on desktop and mobile browsers.Since end users have different screen sizes and different network performance, we want to create multiple renditions ofthe video with different resolutions and bitrates that can be switched seamlessly, this concept is called MBR (Multi Bit Rate).For this task we will use ffmpeg,a powerful tool that supports conversion of various video formats from one to another, including HLS both as input and output. In this guide will show a real world use of ffmpeg to create MBR HLS VOD stream from a static input file. Installing FFMPEG&para; ffmpeg is a cross platform program that can run on Windows and OS X as well as Linux. Windows&para; OS X&para; Ubuntu&para; CentOS / Fedora&para; Latest binaries for all platforms, source code and more information is available at ffmpeg’s official website Source Media&para; I will use a .mkv file beach.mkv, though ffmpeg will consume most of the common video formats. sample files can be downloaded from here and here. To inspect the file properties run the following command:  The file is identified as mkv, 21 seconds long, overall bitrate 19264 kbps, containing one video stream of 1920x1080 23.98fps in h264 codec,and one AC3 audio stream 48kHz 640 kbps. Multi Bitrate Conversion&para; First rendition&para; Lets build a command for one rendition: This will generate a VOD HLS playlist and segments in beach folder. Multiple renditions&para; Each rendition requires its own parameters, though ffmpeg supports multiple inputs and outputs so all the renditions can be generated in parallel with one long command.it's very important that besides the resolution and bitrate parameters the commands will be identical so that the renditions will be properly aligned,meaning key frames will be set in the exact same positions to allow smooth switching between them on the fly. We will create 4 renditions with common resolutions: Master playlist&para; The HLS player needs to know that there are multiple renditions of our video, so we create an HLS master playlist to point themand save it along side the other playlists and segments. playlist.m3u8 Example Conversion Script&para; Here is an example conversion script create-hls-vod.sh Running: will produce: FAQ&para; How to choose the right bitrate&para; Bitrate is dependant mostly on the resolution and the content type.When setting bitrate too low an image pixelization will occur especially in areas where there is rapid movement,when bitrate is too high the output files might be excessively big without additional value. To choose the right bitrate one must understand his type of content. Content with high motion such as sports or news events will require higherbitrate to avoid pixelization while low motion content such as music concerts and interviews will suffice lower bitrate without apparent changes to quality. Here are some good defaults to start from: How do I feed ffmpeg through stdin?&para; ffmpeg has a special pipe: flag that instruct ffmpeg to consume stdin as media. What’s the difference between avconv and ffmpeg&para; avconv is a fork (clone) of ffmpeg that was created by a group of developers of ffmpeg due to project management issues.While both are actively maintained, its recommended to use ffmpeg since it has larger community as explained here [FFmpeg-user] HLS stream to RTMP conversion with ffmpeg   Real-Time Messaging Protocol (RTMP) in Nimble Streamer Nimble Streamer takes published and pulled RTMP to make outgoing RTMP streams for further playback, re-publishing and further usage by other software. This makes Nimble to be an efficient full-cycle RTMP streaming solution. Enhanced interleaving compensation can be set up in case when your audio and video are unsynchronized. Nimble Streamer supports RTMP over SSL (RTMPS) to perform secure transmission in all supported modes. The content may also be taken as input via RTSP, SRT, NDI, WebRTC, MPEG2TS, Icecast and SHOUTcast. You can also convert HLS to RTMP the same transmuxing engine. Farewell to Flash Before diving into wide Nimble Streamer RTMP feature set, take a look at our Get ready for Flash farewell and RTMP decline article about future discontinuity of Flash support by Adobe in 2020.We describe the need to transitioning from RTMP to other technologies for playback purposes and we propose SLDP as an alternative. However, RTMP is still a powerful tool for a lot of use cases so take a look below at what we have. Codecs Video: Producing HLS and MPEG-DASH Playback Nimble provides RTMP playback from any incoming RTMP stream.The output can be pulled for re-use and playback by any player, encoder or server software. Recording Nimble Streamer has DVR feature set which allows recording of incoming RTMP live streams for further playback via HLS and MPEG-DASH. Pull by request Nimble Streamer can create RTMP and HLS streams by request from pulled RTMP sources in case you have streams which you don't want to pull 24/7.This is helpful when you have many stations or cameras which are not required to be transmuxed all the time. Republishing You can set up RTMP republishing for incoming published and pulled streams. With that being set up, you can bring live streams to edge servers for further usage like transmuxing.You can build live streaming networks with various origins and edges connected via RTMP as well as other supported protocols. Notice that you may add and remove republishing rules via WMSPanel API as well as via Nimble Streamer native API in addition to WMSPanel web UI.With that capability you can re-stream your content in the following use cases: Re-package into other live protocols Same transmuxing engine allows re-packaging RTMP content into the following protocols. Server-Side Ads Insertion for RTMP Nimble Advertizer supports inserting of advertising into RTMP live streams on server side.Advertizer allows implementing custom business logic for pre-roll and mid-roll with user-specific insertion and SCTE-35 markers support.Visit Advertizer page for technical specs and other details. Hot swap Hot swap capabilities allow switching between source origin and substitute streams with no glitches or artifacts: API and control RTMP streaming can be controlled in a few other ways besides WMSPanel web UI settings. Aliasing Stream aliases are available for making flexible security settings and statistics. Usage snapshot Usage snapshot shows example of combined usage of Softvelum products including processing camera input. Qosifire: RTMP streaming quality monitoring Qosifire is live streaming quality monitoring service, it allows checking live RTMP for protocol-specific issues.Your on-premise monitoring agent checks the stream 24/7 and notifies our web service about issues, in order to send mobile alerts to your admins.Check RTMP monitoring features and screencast to see how Qosifire can help you.Sign up for 14-days free trial or run 30-seconds free check-up to make sure your stream is available is consistent. Easy installation and upgrade Nimble Streamer can be installed in a couple of small steps and upgraded to the latest version by running two or three simple commands in console. Let us know if you need any help and search through our documentation to find more information. This website or its third-party tools use cookies, which are necessary to its functioningand required to achieve the purposes illustrated in thePrivacy Policy.If you want to know more or withdraw your consent to all or some of the cookies, pleaserefer to thePrivacy Policy.By closing this banner, scrolling this page, clicking a link or continuing to browse otherwise,you agree to the use of cookies. Video live streaming: Notes on RTMP, HLS, and WebRTC Kwindla Kramer Kwindla (CEO) got started designing tools for kids to learn coding. That grew into explorations of collaboration systems; he&#x27;s been building video calling frameworks since the days of the Nokia 6600. More posts by Kwindla Kramer. Kwindla Kramer These days, when people talk about &quot;live streaming,&quot; they might be talking about three quite different underlying technologies. Why are there three standards? Well, partly these standards evolved over time, and are still evolving. Our computers and phones and networks continue to get faster, people keep thinking up new things to do with faster computers and networks, and better and better technical building blocks are created to support these new things we're all doing. But also, delivering video at scale is challenging, and engineering trade-offs abound. HLS and WebRTC are nice examples of two (good) approaches to solving a problem (video streaming) that optimize for very different aspects of that problem. From RTMP to HLS: Two decades of progress in live streaming RTMP is 20 years old, and was originally developed by Macromedia for the Flash server and player. That's pretty ancient technology in Internet video terms. But because RTMP has been around so long, it's widely supported as a way to send live video from one computer system to another. If you are a Twitch streamer, for example, you're almost certainly using RTMP to send video from your gaming machine/music studio/vibe lab to Twitch's cloud infrastructure. On the other hand, if you're watching a stream on Twitch, you're not watching that original RTMP stream. Twitch uses a much newer standard, HLS, to deliver video to the millions and millions of people who watch live streams every day.[1] There are quite a few nice things about HLS, but two advantages in particular over RTMP. First, HLS supports multiple bitrates and allows viewing clients to switch between multiple bitrates dynamically. This is generally important for video delivery at scale, and it's especially important for live streams. If I'm watching a video on my phone on a not-very-great cellular data connection, I have a lot less bandwidth available than if I were watching the same video at home where my Internet connection is (usually) very fast.[2] What this means is that I actually need to watch a different encoding of the video if I'm on my cellular data connection than if I'm using my home internet. On my phone, I just want to see the video and I know the quality's not going to be great. At home, I want the best quality video available. A further wrinkle is that the bandwidth I have available might change while I’m watching the video. My phone could move closer to a cell tower and have faster service. Or at home, my laptop might decide to download a big system update which could cut in half the bandwidth available for video. Just the chunks, ma’am To support dynamic playback bitrates, HLS video is packaged as a series of short time chunks. Each chunk is encoded at several different bitrates. A typical HLS &quot;bitrate ladder&quot; today will include five encodings ranging from about 6 megabits per second on the high end to about 250 kilobits per second at the bottom. (Higher bitrates deliver higher video quality.) Video players that support HLS are able to continuously monitor approximately how much bandwidth is available and to switch to downloading smaller-bitrate or larger-bitrate chunks. The metadata about chunks is stored in manifest files, which are usually named something.m3u8. If you open Chrome devtools and start playing a video on Twitch, you can look in the network panel for fetches of .m3u8 file segments, and see a bunch of interesting information about the HLS encoding! Standing on the shoulders of giants The second advantage that HLS has over RTMP is that the HLS chunks can be delivered efficiently by HTTP CDNs like Cloudflare, Fastly, Akamai, and Cloudfront. &quot;HLS&quot; is an acronym that expands to &quot;HTTP Live Streaming.&quot; HLS chunks and manifests mostly just look like files. Players fetch manifests and chunks with normal HTTP requests. So HLS benefits from the amazing capabilities of modern CDNs. RTMP, on the other hand, is its own TCP-level thing. It is a streaming-oriented protocol, rather than a request-oriented protocol like HLS. To send video and audio over an RTMP connection, you open up a TCP socket and you start pushing RTMP-formatted data over that socket. An enormous amount of infrastructure engineering work has gone into making HTTP fast, scalable, and cost effective everywhere in the world. The CDN-friendly nature of HLS was a core design goal and is a big deal. But there's a catch. Latency. Which will bring us to WebRTC. But first… an interlude on latency Let's do some hand-waving and define the latency we're interested in for live streaming as &quot;the end-to-end delay between a video sender and a video viewer.&quot; Here's a very schematic view of the stages that video bits go through to get from a video sender to a viewer, relayed through a media server: For each of these steps, there are complicated trade-offs between video quality, reliability, cost, and latency.[3] With today's fast computers and nifty video codecs it's possible to compress video at fairly high quality with just a few tens of milliseconds of latency delay. Similarly, networking in general is pretty fast. We've gotten good at routing packets on the Internet. Steps 1-6 typically add up to somewhere between 50ms and 300ms. Except... for possible knock-on effects from how we choose to encode, package, and transfer the video data. (Steps two through four, above.) The chunked, request-oriented approach of HLS forces a lot of extra latency at several stages. Six seconds is a typical HLS chunk length.[4] To oversimplify a little bit, that means there's six seconds of latency added to the pipeline while we encode, package, and upload each chunk. Then our CDN has to fetch and cache the chunks. And finally, on the viewer side, most players will download two full chunks and cache them locally before starting to play the video while the third chunk is downloading. Our latency is now somewhere between 12 and 20 seconds. It's possible to push HLS latency down by using shorter chunk sizes, streaming the chunk uploads to our CDN origin server, extending our CDN's low-level mechanics so that data can start propagating while chunks are in flight, and optimizing buffering on the playback side. All of these changes make playback less resilient and cut against the core engineering trade-off at the heart of HLS: optimizing video for delivery via HTTP infrastructure. Below chunk sizes of about one second, we lose most of the benefits of delivering video via CDNs.[4:1] A request-oriented approach like HLS can therefore get down to about two seconds of latency in the best case, and four or five seconds of latency in the typical case. If our target latency is lower than that, we'll need to take a different approach. WebRTC – an industry standard for low-latency audio and video WebRTC is a stream-oriented standard (like RTMP) that supports adaptive bitrates and is natively supported in today's web browsers (like HLS). Low latency was the primary design goal of WebRTC. With WebRTC, video encoding happens on the sending side and video is sent as a continuous stream. WebRTC media servers don't usually transcode the video.[5] When possible, WebRTC connections are UDP rather than TCP, which lowers networking overhead and latency. And, finally, on the receiving side, a typical playback buffer is 30ms, rather than HLS's typical multi-second buffers. All of this together means that WebRTC end-to-end latency will usually be between 50ms and 200ms. That's low enough to work well for two people having a conversation and is in line with typical latencies for telephone calls. WebRTC's low latency comes with two big trade-offs. First, the approach to maintaining video quality has to be different from the approach that HLS relies on. And second, it's harder to support large audiences with WebRTC. Bandwidth and packet loss From a network engineer's perspective, video quality hinges on the answers to just two simple questions: These two metrics are both important, and because a network stack is a complicated layer cake of protocols, they interact with each other in interesting and sometimes surprising ways.[6] In all cases, though, the end user experience of a “worse network” is the same because there are only two degrees of freedom available to the video stack: the video either pauses while the player buffers (or re-buffers), or the user sees a lower-quality (lower-bitrate) version of the video. Very approximately, as packet loss or jitter go up, the effective bandwidth of a connection goes down. However, it's fair to say that at moderate levels of packet loss, if you don't care too much about latency, you can just buffer a lot of packets and not think too much about packet loss and jitter.[7] Buffering a lot of packets — many seconds worth of packets — is the approach that HLS takes to maintaining video quality in the face of real-world network behavior. Microwave ovens and latency budgets Let's say you're using your home wifi connection to watch a movie on Netflix.[8] You decide to microwave some popcorn. Your wifi connection is using one of the 2.4ghz bands, so packet loss on the network spikes terribly as soon as the microwave oven turns on. HLS can deal with this pretty well. There's already several seconds of video cached, so that video keeps playing just fine. The player will notice that the in-progress chunk downloads are taking longer. If the packet loss spike was shorter than a few seconds, TCP retries will probably just compensate for the packet loss and the player won't need to do anything at all. If the packet loss continues, the player has plenty of time to decide whether to switch gears and start downloading lower-bitrate chunks. The very tight latency budget for WebRTC makes for a completely different situation. WebRTC playback buffers usually don't hold more than 50ms or so of video packets. If there's a big packet loss spike, the player can't just keep rendering cached video data. And the round-trip time to re-request a lost packet will often be slow enough that it's not worth asking the server to send us packets we missed.[9] Finally, the player has to make any decision about hopping down to a lower bitrate very quickly. All of this together means that the typical WebRTC failure mode for dropped packets is just to skip that packet and continue playing the video as well as possible.[10] In a real-time video call, video quality issues look like small framerate glitches, worsening to either visual corruption or long freezes if a video keyframe is missed.[11] To compensate for packet loss, the media server and the player can cooperate to choose a lower bitrate stream. But that probably won't happen quickly enough to avoid visual artifacts. To compensate for all of this, WebRTC implementations usually default to somewhat lower bitrates than HLS implementations do. HLS is more resilient to network issues, at the cost of much higher latency than WebRTC. WebRTC can deliver sub-200ms latencies in the average case (and sub-400ms latencies almost always) but at somewhat lower average video quality. If interactive latencies – latencies below 400ms – are the goal, WebRTC's trade-offs are clearly the right ones. Not all heroes wear capes (some of them carry pagers) The other big difference between HLS and WebRTC is how difficult it is to support large audiences for a live stream and large numbers of users across a service or application. HLS offloads to HTTP CDNs most of the complexity of scaling up distribution. This is great, because modern CDNs are very good. WebRTC is newer than HTTP, and vastly fewer engineering hours have gone into building infrastructure at scale for WebRTC than for HTTP. However, more and more work is going into WebRTC infrastructure, because low-latency video is more and more widely used. A number of companies now offer scalable WebRTC infrastructure as a service. And an increasing number of open source projects provide excellent building blocks for deploying production infrastructure and for experimenting with new approaches.[12] Improving WebRTC infrastructure The big challenges involved in building out a &quot;WebRTC CDN&quot; are: Media servers need to copy incoming UDP video and audio packets and route the copies to each viewer of a live stream. This has to be done fast. This copy-and-routing job is relatively inexpensive from a compute perspective, and it's relatively simple conceptually. But down at the implementation level, there are a number of tricky components, such as estimating the bandwidth available to each viewer and switching to different bitrates as needed. At some point, the number of packets that need to be routed exceeds the limits of a single machine. So it's necessary to implement cascading or mesh networking between servers. Relatedly, the building blocks that are now standard for horizontally scaling HTTP and other request-oriented workloads don’t really work for WebRTC servers. So to scale an application or service (lots of live sessions in parallel) requires writing custom scale-out/scale-in logic, implementing appropriate service discovery, creating new monitoring and observability tooling, etc, etc. Packet loss and jitter are generally much lower when connecting to nearby servers than to servers that are far away. So if the audience for a live stream is geographically distributed, it's important to have a distributed infrastructure of media servers and (again) necessary to implement mesh or cascading server-to-server media transit. Encoding a stream in real time for playback with very small buffers is challenging. The current state of the art is to encode to three bitrates (rather than to five or six, as is typical with HLS). Today, WebRTC is mature enough that for live streams with 15,000 viewers, it's often preferable to use WebRTC over HLS. Low latency allows features like bringing viewers onto a &quot;stage&quot; to participate in the live stream, interactive audience features like polls and emoji reactions, and real-time bidding in live auctions. As WebRTC infrastructure continues to improve, larger and larger low-latency live streams are likely to become more and more widely used. Twitch's servers transcode the RTMP video to HLS in real time. And that transcoding is actually multiple encodes to generate streams at several different bitrates. (Six bitrates, today at least. I just started watching a random Twitch stream in Chrome, and looked at the manifest files in the devtools network console, to check.) That's really impressive. Did I mention that computers keep getting faster? ↩︎ And also things like battery life, but we're trying to keep this explanation relatively simple. ↩︎ Chunk sizes are typically between five and ten seconds because chunks that are at least that big make it easy for clients to buffer enough video to keep playing even when there’s a temporary decrease in network bandwidth, and having relatively big chunks improves CDN performance (and cost) by increasing the likelihood that the chunks will be cached and served directly from the CDN’s edge nodes. ↩︎ As mentioned in the previous footnote, small chunks have lower CDN cache hit rates. To decide which chunk to download, the player needs to look at recent network performance. With smaller chunks, the player must average network performance over a shorter time window, so bitrate variance is higher. There are also more chunks, which adds to cache pressure. Finally, chunk downloads will overlap for a larger percentage of wall clock time, complicating bandwidth estimation. ↩︎ ↩︎ Media servers are a big topic, in and of themselves. For our purposes here, it's sufficient to note that WebRTC media servers typically just route packets rather than transcode video. Routing is much cheaper than transcoding in both time and dollars, both of which are important to scaling to large numbers of simultaneous viewers. ↩︎ Most Internet speed test tools only show you bandwidth. They don't show packet loss and jitter. They don't test for cliffs in packet loss by ramping up bandwidth slowly. (Non-linear fall-offs in effective bandwidth are the norm on real-world connections). Finally, many ISPs prioritize packets going to/from the big speed test origins. (I’m shocked, shocked to find that gambling is going on in here!) So … most speed tests are only very vaguely useful for testing whether a video call will work well. ↩︎ Sincere apologies to any queuing theory afficionados who are unhappy about this extreme over-simplification. ↩︎ Netflix does not use HLS. Netflix uses a custom version of MPEG-DASH. So do YouTube and HBO Max. (Well, YouTube is partly a testbed for new Google technologies, so it's a little bit hard to generalize about YouTube.) MPEG-DASH is similar enough to HLS that it's fine for the purposes of this article to treat them as the same thing. My understanding is that Netflix uses DASH partly for historical reasons and partly because DASH supports DRM better (for some version of &quot;better&quot;) than HLS does. ↩︎ Remember that we're using UDP rather than TCP, so the player logic has to request missed packets. There's no automatic mechanism for that in UDP. ↩︎ Interestingly, the &quot;very bad network&quot; failure mode for the HLS approach is arguably worse than the &quot;very bad network&quot; failure mode of WebRTC. An HLS connection that can't maintain sustained real-time download and exhausts its (big) buffer will have to buffer until new chunks can load. Thanks to this failure mode and to YouTube's UI for it, &quot;buffering&quot; is a universally understood technical concept. On the other hand, a WebRTC implementation can always just play whatever video frames are able to squeeze through the bad network connection. Queueing theorists, are you happier now? ↩︎ Keyframes and encoding strategies for video resilience is another big and interesting topic. Check out Daily engineer Vanessa's glitch art talk on the subject. ↩︎ Companies that support large WebRTC live streams as a major feature of their commercial platforms include Millicast, Agora, and Daily. Open source WebRTC media server projects of note include Jitsi, Mediasoup, and Pion. Zoom offers low latency live streams using a proprietary media stack that is broadly similar to WebRTC. Most of the technical discussion of WebRTC in this article applies, more or less, to Zoom's (very good) stack, too. Zoom's proprietary stack does not run natively in the web browser, however, so Zoom's low latency live streams require using Zoom's native client apps. ↩︎       Get updates from Daily Building on video? Subscribe to our newsletter for all the latest product releases, tutorials, and more from Daily. Introducing 15,000 person real-time interactive live streams Developers building large scale video experiences can create 15,000 person sessions with 10 active participants, at latencies improved over traditional streams Our new pricing: Even more free minutes, automatic volume discounts New pay-as-you-go pricing for developers, focused on simplicity and scalability Enable RTMP Streaming in Your Event RTMP, which stands for Real-Time Messaging Protocol, is a&nbsp;TCP-based protocol&nbsp;that ensures you a smooth streaming experience. At Livestorm, we're using AWS IVS service that can accommodate RTMP ingestion and conversion to a live HLS stream with very low latency (~5s) and Full HD resolution (up to 1080p). If you're using professional audio and video production setups, you might want to use RTMP streaming for your events. In this article, we're going to explain to you how to enable RTMP streaming on your Livestorm event sessions and how to set up your live video streaming software.  This feature is only available for Enterprise customers under a plan with&nbsp;monthly active contacts. In this article RTMP Specifications Enable RTMP Streaming in Livestorm You can enable RTMP streaming directly from your dashboard. Enabling RTMP streaming won't be working if you've already hosted a session of the same event without RTMP.     Set Up Your Live Video Streaming Software Once you've enabled your RTMP source on your Livestorm event session, you can go to your live video streaming software like OBS, XSplit, etc. We're using OBS for this tutorial but the setup is pretty similar on any other similar software.&nbsp;😉   Host a Livestorm Event With RTMP Streaming Once you've enabled your RTMP source on your Livestorm Event Session and you've set up your live video streaming software with it, you can start hosting your event with RTMP streaming. Livestorm Tip&nbsp;👉 Start streaming a few minutes before your live event to make sure everything works perfectly.&nbsp;😉   Troubleshooting No RTMP Stream Detected If you see the following screen when joining your event room, it either means that:&nbsp;  Attendees See a Black Screen in the Room If your attendees see a black screen in the room and no stream, ask them to refresh their page and it should be working again.&nbsp;👌 Related Articles Categories &copy; Livestorm 2022. Powered by Help Scout HTTP Live Streaming HTTP Live Streaming (also known as HLS) is an HTTP-based adaptive bitrate streaming communications protocol developed by Apple Inc. and released in 2009. Support for the protocol is widespread in media players, web browsers, mobile devices, and streaming media servers. As of 2019, an annual video industry survey has consistently found it to be the most popular streaming format.&#91;2&#93; HLS resembles MPEG-DASH in that it works by breaking the overall stream into a sequence of small HTTP-based file downloads, each downloading one short chunk of an overall potentially unbounded transport stream. A list of available streams, encoded at different bit rates, is sent to the client using an extended M3U playlist.&#91;3&#93; Based on standard HTTP transactions, HTTP Live Streaming can traverse any firewall or proxy server that lets through standard HTTP traffic, unlike UDP-based protocols such as RTP. This also allows content to be offered from conventional HTTP servers and delivered over widely available HTTP-based content delivery networks.&#91;4&#93;&#91;5&#93;&#91;6&#93; The standard also includes a standard encryption mechanism&#91;7&#93; and secure-key distribution using HTTPS, which together provide a simple DRM system. Later versions of the protocol also provide for trick-mode fast-forward and rewind and for integration of subtitles. Apple has documented HTTP Live Streaming as an Internet Draft (Individual Submission), the first stage in the process of publishing it as a Request for Comments (RFC). As of December 2015, the authors of that document have requested the RFC Independent Stream Editor (ISE) to publish the document as an informational (non-standard) RFC outside of the IETF consensus process.&#91;8&#93;In August 2017, .mw-parser-output cite.citation{font-style:inherit;word-wrap:break-word}.mw-parser-output .citation q{quotes:"\"""\"""'""'"}.mw-parser-output .citation:target{background-color:rgba(0,127,255,0.133)}.mw-parser-output .id-lock-free a,.mw-parser-output .citation .cs1-lock-free a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/6/65/Lock-green.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-limited a,.mw-parser-output .id-lock-registration a,.mw-parser-output .citation .cs1-lock-limited a,.mw-parser-output .citation .cs1-lock-registration a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/d/d6/Lock-gray-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .id-lock-subscription a,.mw-parser-output .citation .cs1-lock-subscription a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/a/aa/Lock-red-alt-2.svg")right 0.1em center/9px no-repeat}.mw-parser-output .cs1-ws-icon a{background:linear-gradient(transparent,transparent),url("//upload.wikimedia.org/wikipedia/commons/4/4c/Wikisource-logo.svg")right 0.1em center/12px no-repeat}.mw-parser-output .cs1-code{color:inherit;background:inherit;border:none;padding:inherit}.mw-parser-output .cs1-hidden-error{display:none;color:#d33}.mw-parser-output .cs1-visible-error{color:#d33}.mw-parser-output .cs1-maint{display:none;color:#3a3;margin-left:0.3em}.mw-parser-output .cs1-format{font-size:95%}.mw-parser-output .cs1-kern-left{padding-left:0.2em}.mw-parser-output .cs1-kern-right{padding-right:0.2em}.mw-parser-output .citation .mw-selflink{font-weight:inherit}RFC&#160;8216 was published to describe version 7 of the protocol.&#91;9&#93; Contents Architecture[edit] HTTP Live Streaming uses a conventional web server, that implements support for HTTP Live Streaming (HLS), to distribute audiovisual content and requires specific software, such as OBS to fit the content into a proper format (codec) for transmission in real time over a network.The service architecture comprises: Features[edit] HTTP Live Streaming provides mechanisms for players to adapt to unreliable network conditions without causing user-visible playback stalling. For example, on an unreliable wireless network, HLS allows the player to use a lower quality video, thus reducing bandwidth usage. HLS videos can be made highly available by providing multiple servers for the same video, allowing the player to swap seamlessly if one of the servers fails. Adaptability[edit] To enable a player to adapt to the bandwidth of the network, the original video is encoded in several distinct quality levels. The server serves an index, called a "master playlist", of these encodings, called "variant streams". The player can then choose between the variant streams during playback, changing back and forth seamlessly as network conditions change. Using fragmented MP4[edit] At WWDC 2016 Apple announced&#91;11&#93; the inclusion of byte-range addressing for fragmented MP4 files, or fMP4, allowing content to be played via HLS without the need to multiplex it into MPEG-2 Transport Stream. The industry considered this as a step towards compatibility between HLS and MPEG-DASH.&#91;12&#93;&#91;13&#93; Low Latency HLS[edit] Two unrelated HLS extensions with a "Low Latency" name and corresponding acronym exist: The remainder of this section describes Apple's ALHLS. It reduces the glass-to-glass delay when streaming via HLS by reducing the time to start live stream playbacks and maintain that time during a live streaming event. It works by adding partial media segment files into the mix, much like MPEG-CMAF's fMP4. Unlike CMAF, ALHLS also supports partial MPEG-2 TS transport files. A partial media segment is a standard segment (e.g. 6 seconds) split into equal segments of less than a second (e.g. 200 milliseconds).&#160; The standard first segment is replaced by the series of partial segments.&#160; Subsequent segments are of the standard size.&#91;16&#93; HTTP/2 is required to push the segments along with the playlist, reducing the overhead of establishing repeated HTTP/TCP connections. Other features include: Apple also added new tools: "tsrecompressor" produces and encodes a continuous low latency stream of audio and video. The "mediastreamsegmenter" tool is now available in a low latency version. It is a HLS segmenter which takes in an UDP/MPEG-TS stream from tsrecompressor and generates a media playlist, including the new tags above. Support for low-latency HLS is available in tvOS 13 beta, and iOS &amp; iPadOS 14.&#91;17&#93;On April 30, 2020, Apple added the low latency specifications to the second edition of the main HLS specification.&#91;18&#93; Dynamic ad insertion[edit] Dynamic ad insertion is supported in HLS using splice information based on SCTE-35 specification. The SCTE-35 splice message is inserted on the media playlist file using the EXT-X-DATERANGE tag. Each SCTE-35 splice_info_section() is represented by an EXT-X-DATERANGE tag with a SCTE35-CMD attribute. A SCTE-35 splice out/in pair signaled by the splice_insert() commands are represented by one or more EXT-X-DATERANGE tags carrying the same ID attribute. The SCTE-35 splice out command should have the SCTE35-OUT attribute and the splice in command should have the SCTE35-IN attribute. Between the two EXT-X-DATERANGE tags that contain the SCTE35-OUT and SCTE35-IN attributes respectively there may be a sequence of media segment URIs. These media segments normally represent ad programs which can be replaced by the local or customized ad. The ad replacement does not require the replacement of the media files, only the URIs in the playlist need to be changed to point different ad programs. The ad replacement can be done on the origin server or on the client’s media playing device. Server implementations[edit] Notable server implementations supporting HTTP Live Streaming include: Usage[edit] Supported players and servers[edit] HTTP Live Streaming is natively supported in the following operating systems: Windows 10 used to have native support for HTTP Live Streaming in EdgeHTML, a proprietary browser engine that was used in Microsoft Edge (now referred to as Edge Legacy) before the transition to the Chromium-based Blink browser engine. Edge Legacy was included in Windows 10 up till version 2004. It was replaced by Edge Chromium in version 20H2. Along with Windows 11, Microsoft released an updated Media Player that supports HLS natively. Clients[edit] Has full HLS support. Support via Media Source Extensions on Edge Chromium. No native support on Edge Chromium from version 79 to present.&#91;33&#93; Support via Media Source Extensions on other OS. Android and iOS have OS-dependent native support. Other platforms require Media Source Extensions. Support via Media Source Extensions on other OS. Other platforms require Media Source Extensions. Has full HLS support. Has full HLS support. To play a HLS stream, go to File &gt; Open Stream and replace "http://" with "itls://" (for video streams) or "itals://" (for audio streams) in the stream URL. iPhone, iPad, and AppleTV Plays Internet Radio Streams HLS Audio - 100% Compliant AAC-LC/HE-AAC/xHE-AAC 2.0 Stereo/5.1-7.1 Surround ES - Elementary Stream ADTS fMP4 - Fragmented ISO MP4 Displays Synchronous Realtime Metadata and Graphics VLC 3.0 has full HLS support. Servers[edit] Supported prptpcols IN only: SDVoE and NDI Live Encoders[edit] VOD encoders[edit] See also[edit] References[edit] Navigation menu Personal tools Namespaces Views Search Navigation Contribute Tools Print/export Languages Sorry, there was a problem. Sorry, there was a problem. Image Unavailable ORIVISION H.265 H.264 HD HDMI VGA CVBS Video Decoder,HTTP RTSP RTMP UDP HLS M3U8 SRT Converter IP Streaming to 3G for Decoding Encoder and Camera Facebook YouTube Ustream Wowza Platforms $395.90 $285.00 $222.90 $233.90 $234.90 Products related to this item .sp_detail_sponsored_label { color: #555555; font-size: 11px; } .sp_detail_info_icon { width: 11px; vertical-align: text-bottom; fill: #969696; } .sp_info_link { text-decoration:none !important; } #sp_detail_hide_feedback_string { display: none; } .sp_detail_sponsored_label:hover { color: #111111; } .sp_detail_sponsored_label:hover .sp_detail_info_icon { fill: #555555; } Sponsored Hide feedback (function(f) {var _np=(window.P._namespace("FirebirdSpRendering"));if(_np.guardFatal){_np.guardFatal(f)(_np);}else{f(_np);}}(function(P) { P.when('AmazonClicks').execute(function (AC) { if (AC.registerFeedbackEventsWithSponsoredLabel) { AC.registerFeedbackEventsWithSponsoredLabel("sp_detail_carousel", "sp_detail_feedbackMessage", "sp_detail_hide_feedback_string", "pa_feedbackForm_container_sp_detail"); } }); })); Customers also search From the brand Professional solution provider Orivision is a National High-New-Tech Enterprise and Technology Innovation Enterprise with ISO certified. Who We Are Founded in 2004, ORIVISION is a professional IP/Optical/cable-based video transmission manufacture. We focus on H.265 &amp; H.264 HDMI/SDI/VGA encoders and decoders, HDMI/VGA/SDI/DVI signal transmitters with IP/network/cables/optical fiber and so on. We have mastered the unique technologies in low bitrate encoding, low bandwidth transmission, wired/wireless transmission, NDI/SRT/RTMP/RTSP technology, HD decoding, multi-format conversion and streaming media service management. The products are widely used in military industry, transportation, emergency management, education recording, communications, new media live broadcast, medical teaching and other industries. H.265/H.264 HDMI Video Encoder Customer questions & answers Product Description   Description Product Introduction ORIVISION H.265 H.264 HDMI VGA CVBS Decoder is our professional HD audio &amp; video decoding device. It s for decoding network video&amp;audio stream to HDMI/VGA/CVBS (with stereo audio) local display output. It can receive the RTMP RTSP UDP HTTP HLS FLV network stream from our video encoder or other media server. Output  Audio  System  General Parameters     High Quality  Product Feature  Application  Videos Videos for this product 0:23 Click to play video H.265 HDMI/VGA/CVBS Video Decoder ORIVISION Videos for related products 7:43 Click to play video Demonstration for J-Tech Digital IPTV Encoder JTECH-ENCH4 J-Tech Digital, Inc Videos for related products 2:02 Click to play video AV2HD 2.0 Video Converter &amp; Recorder ClearClick - SoundBeast Videos for related products 0:55 Click to play video J-Tech Digital Smart Control App for Phone to H.264 IPTV Encoder J-Tech Digital, Inc Product guides and documents Product information Feedback Brands in this category on Amazon Products related to this item .sp_detail2_sponsored_label { color: #555555; font-size: 11px; } .sp_detail2_info_icon { width: 11px; vertical-align: text-bottom; fill: #969696; } .sp_info_link { text-decoration:none !important; } #sp_detail2_hide_feedback_string { display: none; } .sp_detail2_sponsored_label:hover { color: #111111; } .sp_detail2_sponsored_label:hover .sp_detail2_info_icon { fill: #555555; } Sponsored Hide feedback (function(f) {var _np=(window.P._namespace("FirebirdSpRendering"));if(_np.guardFatal){_np.guardFatal(f)(_np);}else{f(_np);}}(function(P) { P.when('AmazonClicks').execute(function (AC) { if (AC.registerFeedbackEventsWithSponsoredLabel) { AC.registerFeedbackEventsWithSponsoredLabel("sp_detail2_carousel", "sp_detail2_feedbackMessage", "sp_detail2_hide_feedback_string", "pa_feedbackForm_container_sp_detail2"); } }); })); Customer reviews Customer Reviews, including Product Star Ratings help customers to learn more about the product and decide whether it is the right product for them. To calculate the overall star rating and percentage breakdown by star, we don’t use a simple average. Instead, our system considers things like how recent a review is and if the reviewer bought the item on Amazon. It also analyzed reviews to verify trustworthiness. Reviews with images Top reviews from the United States There was a problem filtering reviews right now. Please try again later. Top reviews from other countries Welcome to AliExpress! Welcome back Sign Out Register Sign in &nbsp; Followers RTMP Pull   A Real-Time Messaging Protocol (RTMP) Pull link is a playable link of your live stream, which you can set up as a source on another broadcast. The RTMP Pull feature allows you to play one live stream inside the other. You can have an original stream playing in the background and your own graphic overlays with the audio commentary in the foreground.  Note: You need at least a Professional plan to use RTMP Pull feature.  How to Set Up RTMP Pull Navigate to your Restream Dashboard and click the "Stream with OBS, Vmix" button. Press the "More" button on the right side of the screen. Press the "Create Link" button. Give your RTMP link a name that will explain its purpose and press "Save". Open the menu for your link to see the details. If you require a single-line RTMP Pull Link, you can merge fields for ease of copying. To use this link, copy it and insert it to your video player as a file path for monitoring, or use it as a media source with FLV type in your streaming application to embed this stream into another stream.Tip: You can use up to 10 active connections to a single RTMP Pull link depending on the plan you have.  RTMP Pull use cases Monitoring stream in real-time in MPC-HC video player Embedding Pull stream into your main stream Embedding several pull streams from different accounts into one stream Tip: 'RTMP Pull' can allow you to create multiple points of view from incoming streams, which means you can switch between the streams of your broadcasters in your main broadcast, for example during ESports tournaments or conventions.Important: Remember that we do not allow embedding RTMP Pull links inside public players anywhere. It is strictly for internal production and monitoring use only - sharing it to the public (ex. using the RTMP pull a link to display your Restream content directly on a public web page) is prohibited. 👉 Next steps Custom RTMP Channel How to Connect OBS Studio to Restream! 👍 Keep exploring RTMP Pull feature: When and why should you use it.  Would you like to learn some tricks from the community? Join our Facebook Community and Twitter.  Can't find the right answer? Contact the Restream Support team via our 24/7 Live Chat  Featured Products Compute Storage Networking Managed Databases Tools and Services Management Tools Try DigitalOcean for free Click here to sign up and get $200 of credit to try our products over 60 days! Our business solutions By use case Our community Resources Get Involved Documentation Related // Tutorial // How To Set Up a Video Streaming Server using Nginx-RTMP on Ubuntu 20.04 Introduction There are many use cases for streaming video. Service providers such as Twitch are very popular for handling the web discovery and community management aspects of streaming, and free software such as OBS Studio is widely used for combining video overlays from multiple different stream sources in real time. While these platforms are very powerful, in some cases you may want to be able to host a stream that does not rely on other service providers. In this tutorial, you will learn how to configure the Nginx web server to host an independent RTMP video stream that can be linked and viewed in different applications. RTMP, the Real-Time Messaging Protocol, defines the fundamentals of most internet video streaming. You will also learn how to host HLS and DASH streams that support more modern platforms using the same technology. Prerequisites To complete this guide, you will need: This tutorial will use the placeholder domain name your_domain for URLs and hostnames. Substitute this with your own domain name or IP address as you work through the tutorial. Step 1 — Installing and Configuring Nginx-RTMP Most modern streaming tools support the RTMP protocol, which defines the basic parameters of an internet video stream. The Nginx web server includes a module that allows you to provide an RTMP stream with minimal configuration from a dedicated URL, just like it provides HTTP access to web pages by default. The Nginx RTMP module isn’t included automatically with Nginx, but on Ubuntu 20.04 and most other Linux distributions you can install it as an additional package. Begin by running the following commands as a non-root user to update your package listings and install the Nginx module: Installing the module won’t automatically start providing a stream. You’ll need to add a configuration block to your Nginx configuration file that defines where and how the stream will be available. Using nano or your favorite text editor, open Nginx’s main configuration file, /etc/nginx/nginx.conf, and add this configuration block to the end of the file: Save and close the file. If you are using nano, press Ctrl+X, then when prompted, Y and Enter. This provides the beginning of your RTMP configuration. By default, it listens on port 1935, which means you’ll need to open that port in your firewall. If you configured ufw as part of your initial server setup run the following command. Now you can reload Nginx with your changes: You should now have a working RTMP server. In the next section, we’ll cover streaming video to your RTMP server from both local and remote sources. Step 2 — Sending Video to Your RTMP Server There are multiple ways to send video to your RTMP server. One option is to use ffmpeg, a popular command line audio-video utility, to play a video file directly on your server. If you don’t have a video file already on the server, you can download one using youtube-dl, a command line tool for capturing video from streaming platforms like YouTube. In order to use youtube-dl, you’ll need an up to date Python installation on your server as well. First, install Python and its package manager, pip: Next, use pip to install youtube-dl: Now you can use youtube-dl to download a video from YouTube. If you don’t have one in mind, try this video, introducing DigitalOcean’s App Platform: You’ll see some output as youtube-dl combines the video and audio streams it’s downloading back into a single file – this is normal. You should now have a video file in your current directory with a title like Introducing App Platform by DigitalOcean-iom_nhYQIYk.mkv. In order to stream it, you’ll want to install ffmpeg: And use ffmpeg to send it to your RTMP server: This ffmpeg command is doing a few things to prepare the video for a streaming-friendly format. This isn’t an ffmpeg tutorial, so you don’t need to examine it too closely, but you can understand the various options as follows: The video is sent to rtmp://localhost/live/stream because you defined the live configuration block in Step 1, and stream is an arbitrarily chosen URL for this video. Note: You can learn more about ffmpeg options from ffmprovisr, a community-maintained catalog of ffmpeg command examples, or refer to the official documentation. While ffmpeg is streaming the video, it will print timecodes: This is standard ffmpeg output. If you were converting video to a different format, these might be helpful in order to understand how efficiently the video is being resampled, but in this case, you just want to see that it’s being played back consistently. Using this sample video, you should get exact fps= 25 increments. While ffmpeg is running, you can connect to your RTMP stream from a video player. If you have VLC, mpv, or another media player installed locally, you should be able to view your stream by opening the URL rtmp://your_domain/live/stream in your media player. Your stream will terminate after ffmpeg has finished playing the video. If you want it to keep looping indefinitely, you can add -stream_loop -1 to the beginning of your ffmpeg command. Note: You can also stream directly to, for example, Facebook Live using ffmpeg without needing to use Nginx-RTMP at all by replacing rtmp://localhost/live/stream in your ffmpeg command with rtmps://live-api-s.facebook.com:443/rtmp/your-facebook-stream-key. YouTube uses URLs like rtmp://a.rtmp.youtube.com/live2. Other streaming providers that can consume RTMP streams should behave similarly. Now that you’ve learned to stream static video sources from the command line, you’ll learn how to stream video from dynamic sources using OBS on a desktop. Step 3 — Streaming Video to Your Server via OBS (Optional) Streaming via ffmpeg is convenient when you have a prepared video that you want to play back, but live streaming can be much more dynamic. The most popular software for live streaming is OBS, or Open Broadcaster Software – it is free, open source, and very powerful. OBS is a desktop application, and will connect to your server from your local computer. After installing OBS, configuring it means customizing which of your desktop windows and audio sources you want to add to your stream, and then adding credentials for a streaming service. This tutorial will not be covering your streaming configuration, as it is down to preference, and by default, you can have a working demo by just streaming your entire desktop. In order to set your streaming service credentials, open OBS’ settings menu, navigate to the Stream option and input the following options: obs_stream is an arbitrarily chosen path – in this case, your video would be available at rtmp://your_domain/live/obs_stream. You do not need to enable authentication, but you do need to add an additional entry to the IP whitelist that you configured in Step 1. Back on the server, open Nginx’s main configuration file, /etc/nginx/nginx.conf, and add an additional allow publish entry for your local IP address. If you don’t know your local IP address, it’s best to just go to a site like What’s my IP which can tell you where you accessed it from: Save and close the file, then reload Nginx: You should now be able to close OBS’ settings menu and click Start Streaming from the main interface! Try viewing your stream in a media player as before. Now that you’ve seen the fundamentals of streaming video in action, you can add a few other features to your server to make it more production-ready. Step 4 — Adding Monitoring to Your Configuration (Optional) Now that you have Nginx configured to stream video using the Nginx-RTMP module, a common next step is to enable the RTMP statistics page. Rather than adding more and more configuration details to your main nginx.conf file, Nginx allows you to add per-site configurations to individual files in a subdirectory called sites-available/. In this case, you’ll create one called rtmp: Add the following contents: Save and close the file. The stat.xsl file from this configuration block is used to style and display an RTMP statistics page in your browser. It is provided by the libnginx-mod-rtmp library that you installed earlier, but it comes zipped up by default, so you will need to unzip it and put it in the /var/www/html/rtmp directory to match the above configuration. Note that you can find additional information about any of these options in the Nginx-RTMP documentation. Create the /var/www/html/rtmp directory, and then uncompress the stat.xsl.gz file with the following commands: Finally, to access the statistics page that you added, you will need to open another port in your firewall. Specifically, the listen directive is configured with port 8080, so you will need to add a rule to access Nginx on that port. However, you probably don’t want others to be able to access your stats page, so it’s best only to allow it for your own IP address. Run the following command: Next, you’ll need to activate this new configuration. Nginx’s convention is to create symbolic links (like shortcuts) from files in sites-available/ to another folder called sites-enabled/ as you decide to enable or disable them. Using full paths for clarity, make that link: Now you can reload Nginx again to process your changes: You should now be able to go to http://your_domain:8080/stat in a browser to see the RTMP statistics page. Visit and refresh the page while streaming video and watch as the stream statistics change. You’ve now seen how to monitor your video stream and push it to third party providers. In the final section, you’ll learn how to provide it directly in a browser without the use of third party streaming platforms or standalone media player apps. Step 5 — Creating Modern Streams for Browsers (Optional) As a final step, you may want to add support for newer streaming protocols so that users can stream video from your server using a web browser directly. There are two protocols that you can use to create HTTP-based video streams: Apple’s HLS and MPEG DASH. They both have advantages and disadvantages, so you will probably want to support both. The Nginx-RTMP module supports both standards. To add HLS and DASH support to your server, you will need to modify the rtmp block in your nginx.conf file. Open /etc/nginx/nginx.conf using nano or your preferred editor, then add the following highlighted directives: Save and close the file. Next, add this to the bottom of your sites-available/rtmp: Note: The Access-Control-Allow-Origin * header enables CORS, or Cross-Origin Resource Sharing, which is disabled by default. This communicates to any web browsers accessing data from your server that the server may load resources from other ports or domains. CORS is needed for maximum compatibility with HLS and DASH clients, and a common configuration toggle in many other web deployments. Save and close the file. Note that you’re using port 8088 here, which is another arbitrary choice for this tutorial to avoid conflicting with any services you may be running on port 80 or 443. You’ll want to open that port in your firewall for now too: Finally, create a stream directory in your web root to match the configuration block, so that Nginx can generate the necessary files for HLS and DASH: Reload Nginx again: You should now have an HLS stream available at http://your_domain:8088/hls/stream.m3u8 and a DASH stream available at http://your_domain:8088/dash/stream.mpd. These endpoints will generate any necessary metadata on top of your RTMP video feed in order to support modern APIs. Conclusion The configuration options that you used in this tutorial are all documented in the Nginx RTMP Wiki page. Nginx modules typically share common syntax and expose a very large set of configuration options, and you can review their documentation to change any of your settings from here. Nearly all internet video streaming is implemented on top of RTMP, HLS, and DASH, and by using the approach that you have explored in this tutorial, you can provide your stream via other broadcasting services, or expose it any other way you choose. Next, you could look into configuring Nginx as a reverse proxy in order to make some of these different video endpoints available as subdomains. Want to learn more? Join the DigitalOcean Community! Join our DigitalOcean community of over a million developers for free! Get help and share knowledge in our Questions &amp; Answers section, find tutorials and tools that will help you grow as a developer and scale your project or business, and subscribe to topics of interest. author Still looking for an answer? This textbox defaults to using Markdown to format your answer. You can type !ref in this text area to quickly search our full set of tutorials, documentation &amp; marketplace offerings and insert the link! Hi! I’m having a problem when trying to load hls stream from a web player it shows “connection refused” status on the network inspector. I can do load the stream via VLC with no problem. Any clue? I already changed the ufw rules and checked it is enabled. also changed the source to obs_stream.m3u8 as commented by matthewdewitt. i find the issue in last nginx.conf file need this rtmp_auto_push on;rtmp {server {listen 1935;chunk_size 4096; hls on;hls_path /media/channels/;hls_fragment 5s;hls_base_url http://192.168.1.135:81/hls/;hls_playlist_length 1m;wait_video on;hls_continuous on;idle_streams on;hls_fragment_slicing aligned;record off; then worked fine for me The file /etc/nginx/sites-available/rtmp is wrong Hi. I have done all the steps and it doesn’t work as expected. I use OBS to stream my webcam as RTMP and I listen the audio but not the webcam!!! No error in the nginx log!!! But when I stream the desktop it shows it!!! What the hell! When I use RTMP to stream the webcam to YouTube RTMP it is ok. Owncast might be a better option. https://owncast.online/.I have been using it to stream my daughters gymnastics for a while now. Here is a little write up I have for deploying Owncast with Traefik using docker on a droplet. https://github.com/clemenko/owncast There seems to be a typo in your config, or an error in mine. When using OBS, the hls stream url is: obs_stream.m3u8 Not: stream.m3u8 This can be validated by checking the contents of /var/www/html/stream/hls while OBS is running. Maybe that’s expected? But you statically specified obs_stream as the key earlier in the document, so I presume this is how the file is created in hls directory. Anyway, a big THANK YOU for this article! Hello, I did try all, check very careful all details, not working… the Nginx works, I don’t have any error on the server… I am running a local server with no firewall… but the streaming is not viewable with VLC or web browser Popular Topics Questions Events Get involved Please complete your information! Sign up for Infrastructure as a Newsletter. Working on improving health and education, reducing inequality, and spurring economic growth? We&#x27;d like to help. You get paid; we donate to tech nonprofits. Welcome to the developer cloud DigitalOcean makes it simple to launch in the cloud and scale up as you grow – whether you’re running one virtual machine or ten thousand. © 2022 DigitalOcean, LLC. All rights reserved.